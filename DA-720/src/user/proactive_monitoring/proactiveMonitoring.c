/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <unistd.h>
#include "proactiveMonitoring.h"
#include "logicProcessorTable.h"
#include "partitionStatusTable.h"
#include "networkStatusTable.h"
#include "serialPortStatusTable.h"

/** Initializes the proactiveMonitoring module */
void
init_proactiveMonitoring(void)
{
  DEBUGMSGTL(("proactiveMonitoring", "Initializing\n"));
    const oid cpuLogicCount_oid[] = { 1,3,6,1,4,1,8691,17,2,1,1 };
    const oid cpuTotalUsage_oid[] = { 1,3,6,1,4,1,8691,17,2,1,2 };
    const oid cpuTemperature_oid[] = { 1,3,6,1,4,1,8691,17,2,1,3 };
    const oid cpuVoltage_oid[] = { 1,3,6,1,4,1,8691,17,2,1,4 };
    const oid memoryUsage_oid[] = { 1,3,6,1,4,1,8691,17,2,2,1 };
    const oid memoryTotalSize_oid[] = { 1,3,6,1,4,1,8691,17,2,2,2 };
    const oid memoryAvailableSize_oid[] = { 1,3,6,1,4,1,8691,17,2,2,3 };
    const oid dramVoltage_oid[] = { 1,3,6,1,4,1,8691,17,2,2,4 };
    const oid mainboardPowerIndicator_oid[] = { 1,3,6,1,4,1,8691,17,2,4,1 };
    const oid mainboardTemperature_oid[] = { 1,3,6,1,4,1,8691,17,2,4,2 };
    const oid mainboardVoltage_oid[] = { 1,3,6,1,4,1,8691,17,2,4,3 };

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpuLogicCount", handle_cpuLogicCount,
                               cpuLogicCount_oid, OID_LENGTH(cpuLogicCount_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpuTotalUsage", handle_cpuTotalUsage,
                               cpuTotalUsage_oid, OID_LENGTH(cpuTotalUsage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpuTemperature", handle_cpuTemperature,
                               cpuTemperature_oid, OID_LENGTH(cpuTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("cpuVoltage", handle_cpuVoltage,
                               cpuVoltage_oid, OID_LENGTH(cpuVoltage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memoryUsage", handle_memoryUsage,
                               memoryUsage_oid, OID_LENGTH(memoryUsage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memoryTotalSize", handle_memoryTotalSize,
                               memoryTotalSize_oid, OID_LENGTH(memoryTotalSize_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("memoryAvailableSize", handle_memoryAvailableSize,
                               memoryAvailableSize_oid, OID_LENGTH(memoryAvailableSize_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("dramVoltage", handle_dramVoltage,
                               dramVoltage_oid, OID_LENGTH(dramVoltage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("mainboardPowerIndicator", handle_mainboardPowerIndicator,
                               mainboardPowerIndicator_oid, OID_LENGTH(mainboardPowerIndicator_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("mainboardTemperature", handle_mainboardTemperature,
                               mainboardTemperature_oid, OID_LENGTH(mainboardTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("mainboardVoltage", handle_mainboardVoltage,
                               mainboardVoltage_oid, OID_LENGTH(mainboardVoltage_oid),
                               HANDLER_CAN_RONLY
        ));

    init_logicProcessorTable();
    init_partitionStatusTable();
    init_networkStatusTable();
    init_serialPortStatusTable();
}


int exec_cmd(char *cmd, char *result)
{
    FILE *fp;
    int ret = 0;

    memset(result, '\0', BUF_SIZE);

    /* Open the command for reading. */
    fp = popen(cmd, "r");

    if (NULL == fp) {
        return -1;
    }

    /* Read the output a line at a time - output it. */
    while (fgets(result, BUF_SIZE - 1, fp) != NULL);

    /* close */
    ret = pclose(fp);

    if ( result[0] == '\0' ) {
        return -1;
    }

    return ret;
}


int
handle_cpuLogicCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    int v;
    switch(reqinfo->mode) {

        case MODE_GET:
            v = sysconf(_SC_NPROCESSORS_ONLN);

            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpuLogicCount\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_cpuTotalUsage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_average_cpu_usage", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = (int) (atof(result) + 0.5);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpuTotalUsage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_cpuTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_temperature 0", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpuTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_cpuVoltage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_milli_volt 0", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cpuVoltage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_memoryUsage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_mem_usage", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memoryUsage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_memoryTotalSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_mem_total_size", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memoryTotalSize\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_memoryAvailableSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_mem_avail_size", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_memoryAvailableSize\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_dramVoltage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_milli_volt 1", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dramVoltage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_mainboardPowerIndicator(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;
    int i;

    switch(reqinfo->mode) {

        case MODE_GET:
            v = 0;
            for (i=0; i<2; i++) {
                sprintf(cmd, "%s get_pwr_status %d", IMPL_FILE, i);
                if (0 == exec_cmd(cmd, result)) {
                    v += atoi(result);
                } else {
                    break;
                }
            }
            if (v == 0) {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_mainboardPowerIndicator\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_mainboardTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_temperature 1", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_mainboardTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_mainboardVoltage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char cmd[BUF_SIZE];
    char result[BUF_SIZE];
    int v;

    switch(reqinfo->mode) {

        case MODE_GET:
            sprintf(cmd, "%s get_milli_volt 2", IMPL_FILE);
            if (0 == exec_cmd(cmd, result)) {
                v = atoi(result);
            } else {
                return SNMP_ERR_NOERROR;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &v,
                                     sizeof(v));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_mainboardVoltage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
